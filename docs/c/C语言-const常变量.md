# C语言学习笔记

>const-常变量：它是定义`只读变量`的关键字,说 const 定义的是变量，但又相当于常量；说它定义的是常量，但又有变量的属性，所以叫`常变量`。

[toc]

## 定义

​	用 const 定义的变量的值是不允许改变的，即`不允许给它重新赋值`，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。

```c
const int a = 5;
/* 或者 */
int const a = 5;
```

## const 与宏定义`常量`区别

```c
#define A 5
const int a = 5;
```



 很多人在学习 const 的时候都会混淆它与 define 的区别。从功能上说它们确实很像，但它们又有明显的不同：

1. `define是预编译指令，而const是普通变量的定义`。define定义的宏是在预处理阶段展开的，而const定义的只读变量是在编译运行阶段使用的。
2. `const定义的是变量，而define定义的是常量`。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。
3. `const定义的是变量，而宏定义的是常量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型`。所以编译器可以对前者进行类型安全检查，而对后者只是机械地进行字符替换，没有`类型安全检查`。这样就很容易出问题，即“边际问题”或者说是“括号问题”。

## 那么const 可以被修改吗？

1.直接赋值，我们知道const定义的是不能被直接赋值的，编译时就会出错。

```c
const.c:9:7: error: assignment of read-only variable ‘a’ 
    a = 10;
        ^
```



2.通过指针修改。

`定义局部常变量：`

```c
#include "stdio.h"

int main(int argc,char * argv )
{
    const int a = 5;
    int  *p = (int *)&a;
    *p = 10; //修改指向a地址的值
    printf("const a = [%d]\r\n",a);
    printf("point p =[%d]\r\n",*p);
    return 0;
}
```

结果：

```c
const a = [10]
point p = [10]
```

我们发现定义的const a确实被以指针的间接方式被修改了（编译器没发现）。const 可以修改，真的是这样吗，看下面的情况。

`定义全局const常变量：`

```c
#include "stdio.h"
const int a = 5;
int main(int argc,char * argv )
{
    int  *p = (int *)&a;
    *p = 10; //修改指向a地址的值
    printf("const a = [%d]\r\n",a);
    printf("point p =[%d]\r\n",*p);
    return 0;
}
```

结果：

```c
段错误 (核心已转储)
```

出现段错误的原因无非就是这么几个：访问一个不存在的地址、访问系统保护的地址、访问只读内存地址、读写一个空指针、堆栈溢出、数组越界等。

3.`const 是如何存储的`

​		全局const变量是`不分配内存地址`的，它编译器放置在符号表中作为编译期常量，全局const变量放在只读数据段中，受到只读数据段的权限保护，当你修改一个只读数据段中的内容时，会得到一个运行时错误。而局部const变量是放在堆栈之中，因为在内存中有地址，通过修改地址中的值可以达到修改const所指内存中值的目的。

`编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。`

## const 使用场景

 





## const & volatile

一，const, volatile含义
（1）const含义是“`请做为常量使用`”，而并非“放心吧，那肯定是个常量”。
（2）volatile的含义是“`请不要做自以为是的优化`，这个值可能变掉的”，而并非“你可以修改这个值”。

二，const, volatile的作用以及起作用的阶段

（1）const 只在编译期有用，在运行期无用
const在编译期保证在C的“源代码”里面，没有对其修饰的变量进行修改的地方（如有则报错，编译不通过），而运行期该变量的值是否被改变则不受const的限制。
（2） volatile 在编译期和运行期都有用
在编译期告诉编译器：请不要做自以为是的优化，这个变量的值可能会变掉
在运行期：`每次用到该变量的值，都从内存中取该变量的值`。

三，const, volatile同时修饰一个变量
（1）合法性
“volatile”的含义并非是“non-const”，volatile 和 const 不构成反义词，所以可以放一起修饰一个变量。
（2）同时修饰一个变量的含义
表示一个变量在程序编译期不能被修改且不能被优化；在程序运行期，变量值可修改，但每次用到该变量的值都要从内存中读取，以防止意外错误。



>参考资料：
>
>[1]:https://blog.csdn.net/u011391093/article/details/45269291
>[2]:http://c.biancheng.net/view/217.html
>[3]:https://www.cnblogs.com/ralap7/p/9115646.html
>[4]:https://blog.csdn.net/ShenJu_DL_ShengHuo/article/details/48241217
>







